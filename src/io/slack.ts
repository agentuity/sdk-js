import { inspect } from 'node:util';
import { SpanStatusCode, context, trace } from '@opentelemetry/api';
import { POST } from '../apis/api';
import { getTracer, recordException } from '../router/router';
import { safeStringify } from '../server/util';
import type { AgentContext, AgentRequest, SlackService } from '../types';

/**
 * Standard event wrapper for the Events API based on Slack schema
 * @see https://api.slack.com/events-api
 */
interface SlackEventData {
	/** The specific name of the event (e.g., `message`, `reaction_added`) */
	type: string;
	/** The epoch timestamp of the event. This, along with team_id, user_id, or channel_id, is intended to be unique */
	event_ts: string;
	[key: string]: unknown;
}

/**
 * Slack message event structure from the Events API
 * @see https://api.slack.com/events/message
 * @see https://api.slack.com/messaging/retrieving
 */
interface SlackMessageEvent extends SlackEventData {
	/** Always 'message' for message events */
	type: 'message';
	/** Optional subtype indicating a special type of message (e.g., 'channel_join', 'message_deleted') */
	subtype?: string;
	/** The ID of the channel, private group, or DM channel where the message was posted */
	channel: string;
	/**
	 * The type of channel where the message was sent:
	 * - `im` - Direct message between users
	 * - `channel` - Public channel
	 * - `group` - Private channel
	 * - `mpim` - Multi-person direct message
	 */
	channel_type?: 'im' | 'channel' | 'group' | 'mpim';
	/** The ID of the user who sent the message */
	user: string;
	/** The actual content of the message */
	text: string;
	/** The unique timestamp of the message within its channel */
	ts: string;
	/** The timestamp of the parent message if this message is part of a thread */
	thread_ts?: string;
	/** Block Kit blocks for rich message content */
	blocks?: SlackBlock[];
	/** Legacy attachments for rich message content */
	attachments?: SlackAttachment[];
	/** Files attached to the message */
	files?: Array<{
		id: string;
		name: string;
		mimetype: string;
		size: number;
		url_private: string;
		url_private_download: string;
		permalink: string;
		[key: string]: unknown;
	}>;
	/** Reactions added to the message */
	reactions?: Array<{
		name: string;
		count: number;
		users: string[];
	}>;
	/** Present if the message has been edited */
	edited?: {
		/** The ID of the user who edited the message */
		user: string;
		/** The timestamp of when the edit occurred */
		ts: string;
	};
	/** Present and true if the calling user has starred the message */
	is_starred?: boolean;
	/** Array containing the IDs of any channels to which the message is currently pinned */
	pinned_to?: string[];
	/** Boolean indicating if the message is part of history but should not be displayed */
	hidden?: boolean;
	/** A unique identifier for the message generated by the client application */
	client_msg_id?: string;
	/** The ID of the bot if the message was sent by a bot */
	bot_id?: string;
	/** The display name of the user or bot who sent the message */
	username?: string;
	/** Contains information about the avatar or icon associated with the sender */
	icons?: {
		image_36?: string;
		image_48?: string;
		image_72?: string;
		[key: string]: unknown;
	};
}

function isSlackMessageEvent(data: SlackEventData): data is SlackMessageEvent {
	return (
		typeof data === 'object' &&
		data !== null &&
		data.type === 'message' &&
		'channel' in data &&
		typeof (data as { channel?: unknown }).channel === 'string' &&
		'ts' in data &&
		typeof (data as { ts?: unknown }).ts === 'string'
	);
}

export class UnsupportedSlackPayload extends Error {}

/**
 * Standard event wrapper payload for Slack Events API
 * @see https://api.slack.com/events-api#the-events-api-request-url
 */
interface SlackEventPayload {
	/** A shared-secret callback token that authenticates the request as coming from Slack */
	token: string;
	/** The unique identifier for the workspace or team where the event occurred */
	team_id: string;
	/** The unique identifier for the Slack application this event is intended for */
	api_app_id: string;
	/** The core payload containing the details of the specific event that occurred */
	event: SlackEventData;
	/** The type of callback you're receiving (typically 'event_callback' for events) */
	type: string;
	/** A unique identifier for this specific event, globally unique across all workspaces */
	event_id: string;
	/** The epoch timestamp in seconds indicating when this event was dispatched */
	event_time: number;
	[key: string]: unknown;
}

/**
 * Text object for Slack Block Kit
 * @see https://api.slack.com/reference/block-kit/composition-objects#text
 */
export interface SlackTextObject {
	/** The formatting to use for this text object. Can be plain_text or mrkdwn */
	type: 'plain_text' | 'mrkdwn';
	/** The text for the text object */
	text: string;
	/** Indicates whether emojis in a text field should be escaped into the colon emoji format. Only for plain_text type */
	emoji?: boolean;
	/** When set to false, disables Slack markup parsing for text objects. Only for mrkdwn type */
	verbatim?: boolean;
}

/**
 * Section block for displaying text, possibly alongside other block elements
 * @see https://api.slack.com/reference/block-kit/blocks#section
 */
export interface SlackSectionBlock {
	type: 'section';
	/** A text object for the main content of the section */
	text?: SlackTextObject;
	/** An array of text objects. When used, these are rendered in a compact, two-column layout */
	fields?: SlackTextObject[];
	/** An optional block element that appears to the right of the text */
	accessory?: unknown; // TODO: Define specific accessory types
	/** A unique identifier for the block */
	block_id?: string;
}

/**
 * Divider block for creating visual separators
 * @see https://api.slack.com/reference/block-kit/blocks#divider
 */
export interface SlackDividerBlock {
	type: 'divider';
	/** A unique identifier for the block */
	block_id?: string;
}

/**
 * Image block for displaying images
 * @see https://api.slack.com/reference/block-kit/blocks#image
 */
export interface SlackImageBlock {
	type: 'image';
	/** A plain-text summary of the image for accessibility */
	alt_text: string;
	/** The URL of the image */
	image_url?: string;
	/** A Slack file object reference */
	slack_file?: {
		url?: string;
		id?: string;
	};
	/** An optional title for the image */
	title?: SlackTextObject;
	/** A unique identifier for the block */
	block_id?: string;
}

/**
 * Header block for displaying text in a larger, bold font
 * @see https://api.slack.com/reference/block-kit/blocks#header
 */
export interface SlackHeaderBlock {
	type: 'header';
	/** A plain-text text object for the header's content */
	text: SlackTextObject;
	/** A unique identifier for the block */
	block_id?: string;
}

/**
 * Context block for displaying contextual information
 * @see https://api.slack.com/reference/block-kit/blocks#context
 */
export interface SlackContextBlock {
	type: 'context';
	/** An array of image elements and text objects (max 10) */
	elements: (
		| SlackTextObject
		| { type: 'image'; image_url: string; alt_text: string }
	)[];
	/** A unique identifier for the block */
	block_id?: string;
}

/**
 * Actions block for holding multiple interactive elements
 * @see https://api.slack.com/reference/block-kit/blocks#actions
 */
export interface SlackActionsBlock {
	type: 'actions';
	/** An array of interactive block element objects */
	elements: unknown[]; // TODO: Define specific element types
	/** A unique identifier for the block */
	block_id?: string;
}

/**
 * Input block for collecting information from users
 * @see https://api.slack.com/reference/block-kit/blocks#input
 */
export interface SlackInputBlock {
	type: 'input';
	/** A plain-text text object for the input's label */
	label: SlackTextObject;
	/** A block element used for user input */
	element: unknown; // TODO: Define specific input element types
	/** If true, dispatches a block_actions payload when the element is interacted with */
	dispatch_action?: boolean;
	/** A unique identifier for the block */
	block_id?: string;
	/** A plain-text text object for hint text below the input */
	hint?: SlackTextObject;
	/** A boolean indicating if the input can be empty */
	optional?: boolean;
}

/**
 * Video block for displaying embedded video players
 * @see https://api.slack.com/reference/block-kit/blocks#video
 */
export interface SlackVideoBlock {
	type: 'video';
	/** Required for accessibility, a plain-text summary of the video */
	alt_text: string;
	/** A plain-text text object for the video title */
	title: SlackTextObject;
	/** A URL for the title text to link to */
	title_url?: string;
	/** A plain-text text object for the video description */
	description?: SlackTextObject;
	/** The URL of the video's thumbnail */
	thumbnail_url: string;
	/** The URL of the embeddable video */
	video_url: string;
	/** The name of the video provider */
	author_name?: string;
	/** The URL of the provider's icon */
	provider_icon_url?: string;
	/** A unique identifier for the block */
	block_id?: string;
}

/**
 * Union type for all Slack Block Kit blocks
 */
export type SlackBlock =
	| SlackSectionBlock
	| SlackDividerBlock
	| SlackImageBlock
	| SlackHeaderBlock
	| SlackContextBlock
	| SlackActionsBlock
	| SlackInputBlock
	| SlackVideoBlock;

/**
 * Legacy attachment structure for Slack messages
 * @see https://api.slack.com/reference/messaging/attachments
 */
export interface SlackAttachment {
	/** Plain-text pretext shown above the attachment */
	pretext?: string;
	/** Main text of the attachment */
	text?: string;
	/** Color used as a left border for the attachment */
	color?: string;
	/** Fields to be displayed in a table-like format */
	fields?: Array<{
		title: string;
		value: string;
		short?: boolean;
	}>;
	/** URL to an image to be displayed in the attachment */
	image_url?: string;
	/** URL to a small thumbnail image to be displayed beside the text */
	thumb_url?: string;
	/** Text to be displayed as a link */
	title?: string;
	/** URL that the title text should link to */
	title_link?: string;
	/** Footer text to be displayed at the bottom */
	footer?: string;
	/** URL to a small icon to be displayed beside the footer text */
	footer_icon?: string;
	/** Unix timestamp for the footer */
	ts?: number;
	[key: string]: unknown;
}

/**
 * Block Kit message content with optional fallback text
 * @see https://api.slack.com/block-kit
 */
export interface SlackBlocksMessage {
	/** Block Kit blocks for rich message content */
	blocks: SlackBlock[];
	/** Fallback text for notifications (recommended) */
	text?: string;
}

/**
 * Legacy attachments message content with optional text
 * @see https://api.slack.com/reference/messaging/attachments
 */
export interface SlackAttachmentsMessage {
	/** Legacy attachments for rich message content */
	attachments: SlackAttachment[];
	/** Main text content of the message */
	text?: string;
}

/**
 * Optional parameters for Slack chat.postMessage API
 * @see https://api.slack.com/methods/chat.postMessage
 */
export interface SlackReplyOptions {
	/**
	 * (Legacy) Pass true to post the message as the authed user instead of as a bot. Defaults to false. Can only be used by classic apps.
	 * @see https://api.slack.com/methods/chat.postMessage#legacy-as_user
	 */
	as_user?: boolean;
	/**
	 * Emoji to use as the icon for this message. Overrides icon_url.
	 */
	icon_emoji?: string;
	/**
	 * URL to an image to use as the icon for this message.
	 */
	icon_url?: string;
	/**
	 * Find and link user groups. No longer supports linking individual users; use syntax shown in Mentioning Users instead.
	 * @see https://api.slack.com/reference/surfaces/formatting#mentioning-users
	 */
	link_names?: boolean;
	/**
	 * JSON object with event_type and event_payload fields, presented as a URL-encoded string.
	 * Metadata you post to Slack is accessible to any app or user who is a member of that workspace.
	 */
	metadata?: string;
	/**
	 * Disable Slack markup parsing by setting to false. Enabled by default.
	 */
	mrkdwn?: boolean;
	/**
	 * Change how messages are treated.
	 * @see https://api.slack.com/methods/chat.postMessage#formatting
	 */
	parse?: string;
	/**
	 * Used in conjunction with thread_ts and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to false.
	 */
	reply_broadcast?: boolean;
	/**
	 * Provide another message's ts value to make this message a reply. Avoid using a reply's ts value; use its parent instead.
	 */
	thread_ts?: string;
	/**
	 * Pass true to enable unfurling of primarily text-based content.
	 */
	unfurl_links?: boolean;
	/**
	 * Pass false to disable unfurling of media content.
	 */
	unfurl_media?: boolean;
	/**
	 * Set your bot's user name.
	 */
	username?: string;
}

/**
 * Internal structure for Slack reply sent through the Agentuity backend
 */
export interface SlackReply {
	/** The agent ID */
	agentId: string;
	/** The channel to reply to */
	channel: string;
	/** Main text content of the message */
	text?: string;
	/** Block Kit blocks for rich message content */
	blocks?: SlackBlock[];
	/** Legacy attachments for rich message content */
	attachments?: SlackAttachment[];
	/** Optional options that are forwarded to Slack chat.postMessage API */
	options?: SlackReplyOptions;
}

export function isSlackEventPayload(data: unknown): data is SlackEventPayload {
	if (typeof data !== 'object' || data === null) return false;
	
	const obj = data as Record<string, unknown>;
	
	return (
		'token' in data &&
		'team_id' in data &&
		'api_app_id' in data &&
		'event' in data &&
		'type' in data &&
		typeof obj.type === 'string' &&
		obj.type === 'event_callback' &&
		'event_id' in data &&
		'event_time' in data
	);
}

/**
 * A class representing a Slack event with the common information so processing can be done on it.
 */
export class Slack implements SlackService {
	private readonly eventPayload: SlackEventPayload;

	constructor(data: unknown) {
		if (isSlackEventPayload(data)) {
			this.eventPayload = data;
			return;
		}
		throw new Error('Invalid Slack event: this slack payload is unsupported');
	}

	[inspect.custom]() {
		return this.toString();
	}

	toString() {
		return JSON.stringify(this.eventPayload);
	}

	get _raw(): unknown {
		return this.eventPayload;
	}

	get payload(): SlackEventPayload {
		return this.eventPayload;
	}

	get message(): SlackMessageEvent {
		if (
			this.eventPayload.type !== 'event_callback' ||
			!isSlackMessageEvent(this.eventPayload.event)
		) {
			throw new UnsupportedSlackPayload('Payload is not Slack message');
		}
		return this.eventPayload.event;
	}

	async sendReply(
		_req: AgentRequest,
		ctx: AgentContext,
		reply: string | SlackBlocksMessage | SlackAttachmentsMessage,
		options?: SlackReplyOptions
	) {
		const tracer = getTracer();
		const currentContext = context.active();

		// Create a child span using the current context
		const span = tracer.startSpan('agentuity.slack.reply', {}, currentContext);

		try {
			// Create a new context with the child span
			const spanContext = trace.setSpan(currentContext, span);

			// Execute the operation within the new context
			return await context.with(spanContext, async () => {
				span.setAttribute('@agentuity/agentId', ctx.agent.id);
				span.setAttribute(
					'@agentuity/slackEventType',
					this.eventPayload.type
				);
				if (
					this.eventPayload.type !== 'event_callback' ||
					!isSlackMessageEvent(this.eventPayload.event)
				) {
					throw new UnsupportedSlackPayload('Payload is not Slack message');
				}
				span.setAttribute(
					'@agentuity/slackTeamId',
					this.eventPayload.team_id
				);

				// Create payload matching backend structure
				let payload: SlackReply;

				if (typeof reply === 'string') {
					// Simple text message
					payload = {
						agentId: ctx.agent.id,
						text: reply,
						channel: this.eventPayload.event.channel,
						options: options,
					};
				} else if ('blocks' in reply) {
					// Block Kit message
					payload = {
						agentId: ctx.agent.id,
						text: reply.text,
						blocks: reply.blocks,
						channel: this.eventPayload.event.channel,
						options: options,
					};
				} else {
					// Attachments message
					payload = {
						agentId: ctx.agent.id,
						text: reply.text,
						attachments: reply.attachments,
						channel: this.eventPayload.event.channel,
						options: options,
					};
				}

				const resp = await POST('/slack/reply', safeStringify(payload), {
					'Content-Type': 'application/json',
					'X-Agentuity-Slack-Team-Id': this.eventPayload.team_id,
				});

				if (resp.status === 200) {
					span.setStatus({ code: SpanStatusCode.OK });
					return;
				}
				throw new Error(
					`error sending slack reply: ${resp.response.statusText} (${resp.response.status})`
				);
			});
		} catch (ex) {
			recordException(span, ex);
			throw ex;
		} finally {
			span.end();
		}
	}
}

/**
 * Parse a Slack event payload from a buffer and return a Slack object.
 */
export async function parseSlack(data: Buffer): Promise<Slack> {
	try {
		const payload = JSON.parse(data.toString());
		return new Slack(payload);
	} catch (error) {
		throw new Error(
			`Failed to parse slack event: ${error instanceof Error ? error.message : 'Unknown error'}`
		);
	}
}
